From ba45237013bd58227555251c565a8cdf12c864ce Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Tue, 1 Sep 2020 08:51:17 +0800
Subject: [PATCH 29/56] HACK: backend-drm: Consider linear and invalid modifier
 are the same

That is true with Rockchip BSP drivers and packages.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 clients/simple-dmabuf-egl.c           | 7 +++++++
 libweston/backend-drm/fb.c            | 8 ++++----
 libweston/backend-drm/state-propose.c | 2 +-
 libweston/linux-dmabuf.c              | 2 +-
 libweston/linux-dmabuf.h              | 4 ++++
 libweston/pixman-renderer.c           | 2 +-
 libweston/renderer-gl/gl-renderer.c   | 4 ++--
 7 files changed, 20 insertions(+), 9 deletions(-)

diff --git a/clients/simple-dmabuf-egl.c b/clients/simple-dmabuf-egl.c
index 10e72a9b..b9a2682d 100644
--- a/clients/simple-dmabuf-egl.c
+++ b/clients/simple-dmabuf-egl.c
@@ -64,6 +64,9 @@
 #define DRM_FORMAT_MOD_INVALID ((1ULL << 56) - 1)
 #endif
 
+#define DRM_MOD_VALID(mod) \
+	((mod) != DRM_FORMAT_MOD_LINEAR && (mod) != DRM_FORMAT_MOD_INVALID)
+
 /* Possible options that affect the displayed image */
 #define OPT_IMMEDIATE     (1 << 0)  /* create wl_buffer immediately */
 #define OPT_IMPLICIT_SYNC (1 << 1)  /* force implicit sync */
@@ -1001,6 +1004,10 @@ dmabuf_modifiers(void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf,
 		 uint32_t format, uint32_t modifier_hi, uint32_t modifier_lo)
 {
 	struct display *d = data;
+	uint64_t modifier = ((uint64_t)modifier_hi << 32) | modifier_lo;
+
+	if (!DRM_MOD_VALID(modifier))
+		return;
 
 	switch (format) {
 	case BUFFER_FORMAT:
diff --git a/libweston/backend-drm/fb.c b/libweston/backend-drm/fb.c
index e7349c4b..0481e71e 100644
--- a/libweston/backend-drm/fb.c
+++ b/libweston/backend-drm/fb.c
@@ -79,7 +79,7 @@ drm_fb_addfb(struct drm_backend *b, struct drm_fb *fb)
 
 	/* If we have a modifier set, we must only use the WithModifiers
 	 * entrypoint; we cannot import it through legacy ioctls. */
-	if (b->fb_modifiers && fb->modifier != DRM_FORMAT_MOD_INVALID) {
+	if (b->fb_modifiers && DRM_MOD_VALID(fb->modifier)) {
 		/* KMS demands that if a modifier is set, it must be the same
 		 * for all planes. */
 		for (i = 0; i < ARRAY_LENGTH(mods) && fb->handles[i]; i++)
@@ -152,7 +152,7 @@ drm_fb_create_dumb(struct drm_backend *b, int width, int height,
 		goto err_fb;
 
 	fb->type = BUFFER_PIXMAN_DUMB;
-	fb->modifier = DRM_FORMAT_MOD_INVALID;
+	fb->modifier = DRM_FORMAT_MOD_LINEAR;
 	fb->handles[0] = create_arg.handle;
 	fb->strides[0] = create_arg.pitch;
 	fb->num_planes = 1;
@@ -290,7 +290,7 @@ drm_fb_get_from_dmabuf(struct linux_dmabuf_buffer *dmabuf,
 
 	/* The legacy FD-import path does not allow us to supply modifiers,
 	 * multiple planes, or buffer offsets. */
-	if (dmabuf->attributes.modifier[0] != DRM_FORMAT_MOD_INVALID ||
+	if (DRM_MOD_VALID(dmabuf->attributes.modifier[0]) ||
 	    dmabuf->attributes.n_planes > 1 ||
 	    dmabuf->attributes.offset[0] > 0) {
 #ifdef HAVE_GBM_FD_IMPORT
@@ -422,7 +422,7 @@ drm_fb_get_from_bo(struct gbm_bo *bo, struct drm_backend *backend,
 	fb->num_planes = 1;
 	fb->strides[0] = gbm_bo_get_stride(bo);
 	fb->handles[0] = gbm_bo_get_handle(bo).u32;
-	fb->modifier = DRM_FORMAT_MOD_INVALID;
+	fb->modifier = DRM_FORMAT_MOD_LINEAR;
 #endif
 
 	if (!fb->format) {
diff --git a/libweston/backend-drm/state-propose.c b/libweston/backend-drm/state-propose.c
index 7af5a2f1..c4c27854 100644
--- a/libweston/backend-drm/state-propose.c
+++ b/libweston/backend-drm/state-propose.c
@@ -156,7 +156,7 @@ drm_output_plane_has_valid_format(struct drm_plane *plane,
 		if (plane->formats[i].format != fb->format->format)
 			continue;
 
-		if (fb->modifier == DRM_FORMAT_MOD_INVALID)
+		if (!DRM_MOD_VALID(fb->modifier))
 			return true;
 
 		for (j = 0; j < plane->formats[i].count_modifiers; j++) {
diff --git a/libweston/linux-dmabuf.c b/libweston/linux-dmabuf.c
index 796e9826..b50c1c77 100644
--- a/libweston/linux-dmabuf.c
+++ b/libweston/linux-dmabuf.c
@@ -480,7 +480,7 @@ bind_linux_dmabuf(struct wl_client *client,
 	int *formats = NULL;
 	uint64_t *modifiers = NULL;
 	int num_formats, num_modifiers;
-	uint64_t modifier_invalid = DRM_FORMAT_MOD_INVALID;
+	uint64_t modifier_invalid = DRM_FORMAT_MOD_LINEAR;
 	int i, j;
 
 	resource = wl_resource_create(client, &zwp_linux_dmabuf_v1_interface,
diff --git a/libweston/linux-dmabuf.h b/libweston/linux-dmabuf.h
index 926dd9e0..b786fbd3 100644
--- a/libweston/linux-dmabuf.h
+++ b/libweston/linux-dmabuf.h
@@ -36,6 +36,10 @@
 #define DRM_FORMAT_MOD_LINEAR 0
 #endif
 
+/* modifier is not linear or invalid */
+#define DRM_MOD_VALID(mod) \
+	((mod) != DRM_FORMAT_MOD_LINEAR && (mod) != DRM_FORMAT_MOD_INVALID)
+
 struct linux_dmabuf_buffer;
 typedef void (*dmabuf_user_data_destroy_func)(
 			struct linux_dmabuf_buffer *buffer);
diff --git a/libweston/pixman-renderer.c b/libweston/pixman-renderer.c
index 42028529..76040ab6 100644
--- a/libweston/pixman-renderer.c
+++ b/libweston/pixman-renderer.c
@@ -1108,7 +1108,7 @@ pixman_renderer_import_dmabuf(struct weston_compositor *ec,
 	int i;
 
 	for (i = 0; i < attributes->n_planes; i++) {
-		if (attributes->modifier[i] != DRM_FORMAT_MOD_INVALID)
+		if (DRM_MOD_VALID(attributes->modifier[i]))
 			return false;
 	}
 
diff --git a/libweston/renderer-gl/gl-renderer.c b/libweston/renderer-gl/gl-renderer.c
index 81062705..a81509da 100644
--- a/libweston/renderer-gl/gl-renderer.c
+++ b/libweston/renderer-gl/gl-renderer.c
@@ -2039,7 +2039,7 @@ import_simple_dmabuf(struct gl_renderer *gr,
 		attribs[atti++] = EGL_YUV_NARROW_RANGE_EXT;
 	}
 
-	if (attributes->modifier[0] != DRM_FORMAT_MOD_INVALID) {
+	if (DRM_MOD_VALID(attributes->modifier[0])) {
 		if (!gr->has_dmabuf_import_modifiers)
 			return NULL;
 		has_modifier = true;
@@ -2479,7 +2479,7 @@ gl_renderer_import_dmabuf(struct weston_compositor *ec,
 
 	for (i = 0; i < dmabuf->attributes.n_planes; i++) {
 		/* return if EGL doesn't support import modifiers */
-		if (dmabuf->attributes.modifier[i] != DRM_FORMAT_MOD_INVALID)
+		if (DRM_MOD_VALID(dmabuf->attributes.modifier[i]))
 			if (!gr->has_dmabuf_import_modifiers)
 				return false;
 
-- 
2.20.1

