From 88018d50df9b84b58d11b4984f049cb3534472a0 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Thu, 11 Nov 2021 18:25:36 +0800
Subject: [PATCH 75/76] kmssink: Support AFBC

Support using ARM AFBC compressed format.

NOTE:
The ARM AFBC compressed format only supported on a few planes of a few
chips.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 sys/kms/gstkmsallocator.c |  15 +++++-
 sys/kms/gstkmssink.c      | 107 ++++++++++++++++++++++++++++++++++++++
 sys/kms/gstkmsutils.h     |  30 +++++++++++
 3 files changed, 150 insertions(+), 2 deletions(-)

diff --git a/sys/kms/gstkmsallocator.c b/sys/kms/gstkmsallocator.c
index a9f0b6361..751914a02 100644
--- a/sys/kms/gstkmsallocator.c
+++ b/sys/kms/gstkmsallocator.c
@@ -36,6 +36,7 @@
 
 /* it needs to be below because is internal to libdrm */
 #include <drm.h>
+#include <drm_fourcc.h>
 
 #include <gst/allocators/gstdmabuf.h>
 
@@ -468,8 +469,18 @@ gst_kms_allocator_add_fb (GstKMSAllocator * alloc, GstKMSMemory * kmsmem,
   GST_DEBUG_OBJECT (alloc, "bo handles: %d, %d, %d, %d", bo_handles[0],
       bo_handles[1], bo_handles[2], bo_handles[3]);
 
-  ret = drmModeAddFB2 (alloc->priv->fd, w, h, fmt, bo_handles, pitches,
-      offsets, &kmsmem->fb_id, 0);
+  if (GST_VIDEO_INFO_IS_AFBC (vinfo)) {
+    uint64_t modifiers[4] = { 0 };
+
+    for (i = 0; i < num_planes && bo_handles[i]; i++)
+      modifiers[i] = DRM_AFBC_MODIFIER;
+
+    ret = drmModeAddFB2WithModifiers (alloc->priv->fd, w, h, fmt, bo_handles,
+        pitches, offsets, modifiers, &kmsmem->fb_id, DRM_MODE_FB_MODIFIERS);
+  } else {
+    ret = drmModeAddFB2 (alloc->priv->fd, w, h, fmt, bo_handles, pitches,
+        offsets, &kmsmem->fb_id, 0);
+  }
   if (ret) {
     GST_ERROR_OBJECT (alloc, "Failed to bind to framebuffer: %s (%d)",
         g_strerror (errno), errno);
diff --git a/sys/kms/gstkmssink.c b/sys/kms/gstkmssink.c
index 81008119e..6169c4b6d 100644
--- a/sys/kms/gstkmssink.c
+++ b/sys/kms/gstkmssink.c
@@ -514,6 +514,79 @@ modesetting_failed:
   }
 }
 
+static gboolean
+support_afbc (GstKMSSink * self, drmModePlane * plane, guint32 drmfmt)
+{
+  drmModeObjectPropertiesPtr props;
+  drmModePropertyBlobPtr blob;
+  drmModePropertyPtr prop;
+  drmModeResPtr res;
+  struct drm_format_modifier_blob *header;
+  struct drm_format_modifier *modifiers;
+  gboolean found;
+  guint64 value;
+  gint i, j;
+
+  res = drmModeGetResources (self->fd);
+  if (!res)
+    return FALSE;
+
+  props = drmModeObjectGetProperties (self->fd, plane->plane_id,
+      DRM_MODE_OBJECT_PLANE);
+  if (!props) {
+    drmModeFreeResources (res);
+    return FALSE;
+  }
+
+  for (i = 0, found = FALSE; i < props->count_props; i++) {
+    prop = drmModeGetProperty (self->fd, props->props[i]);
+    if (prop) {
+      if (!strcmp (prop->name, "IN_FORMATS"))
+        found = TRUE;
+
+      drmModeFreeProperty (prop);
+    }
+
+    if (found) {
+      value = props->prop_values[i];
+      break;
+    }
+  }
+
+  drmModeFreeObjectProperties (props);
+  drmModeFreeResources (res);
+
+  if (!found)
+    return FALSE;
+
+  blob = drmModeGetPropertyBlob (self->fd, value);
+  if (!blob)
+    return FALSE;
+
+  header = blob->data;
+  modifiers = (struct drm_format_modifier *)
+    ((char *) header + header->modifiers_offset);
+
+  for (i = 0, found = FALSE; i < header->count_formats; i++) {
+    for (j = 0; j < header->count_modifiers; j++) {
+      struct drm_format_modifier *mod = &modifiers[j];
+
+      if ((i < mod->offset) || (i > mod->offset + 63))
+        continue;
+      if (!(mod->formats & (1 << (i - mod->offset))))
+        continue;
+
+      if (mod->modifier == DRM_AFBC_MODIFIER) {
+        found = TRUE;
+        break;
+      }
+    }
+  }
+
+  drmModeFreePropertyBlob(blob);
+  return found;
+}
+
 static gboolean
 ensure_allowed_caps (GstKMSSink * self, drmModeConnector * conn,
     drmModePlane * plane, drmModeRes * res)
@@ -572,6 +645,9 @@ ensure_allowed_caps (GstKMSSink * self, drmModeConnector * conn,
       if (!caps)
         continue;
 
+      if (support_afbc (self, plane, plane->formats[j]))
+        gst_caps_set_simple (caps, "arm-afbc", GST_TYPE_INT_RANGE, 0, 1, NULL);
+
       tmp_caps = gst_caps_merge (tmp_caps, caps);
     }
 
@@ -1215,11 +1291,23 @@ gst_kms_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
 {
   GstKMSSink *self;
   GstVideoInfo vinfo;
+  GstStructure *s;
+  gint value;
 
   self = GST_KMS_SINK (bsink);
 
   if (!gst_video_info_from_caps (&vinfo, caps))
     goto invalid_format;
+
+  /* parse AFBC from caps */
+  s = gst_caps_get_structure (caps, 0);
+  if (gst_structure_get_int (s, "arm-afbc", &value)) {
+    if (value)
+      GST_VIDEO_INFO_SET_AFBC (&vinfo);
+    else
+      GST_VIDEO_INFO_UNSET_AFBC (&vinfo);
+  }
+
   self->vinfo = vinfo;
 
   if (!gst_kms_sink_calculate_display_ratio (self, &vinfo,
@@ -1290,7 +1378,9 @@ gst_kms_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
   gboolean need_pool;
   GstVideoInfo vinfo;
   GstBufferPool *pool;
+  GstStructure *s;
   gsize size;
+  gint value;
 
   self = GST_KMS_SINK (bsink);
 
@@ -1302,6 +1392,10 @@ gst_kms_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
   if (!gst_video_info_from_caps (&vinfo, caps))
     goto invalid_caps;
 
+  s = gst_caps_get_structure (caps, 0);
+  if (gst_structure_get_int (s, "arm-afbc", &value) && value)
+    goto afbc_caps;
+
   size = GST_VIDEO_INFO_SIZE (&vinfo);
 
   pool = NULL;
@@ -1340,6 +1434,11 @@ invalid_caps:
     GST_DEBUG_OBJECT (bsink, "invalid caps specified");
     return FALSE;
   }
+afbc_caps:
+  {
+    GST_DEBUG_OBJECT (bsink, "no allocation for AFBC");
+    return FALSE;
+  }
 no_pool:
   {
     /* Already warned in create_pool */
@@ -1572,6 +1671,11 @@ gst_kms_sink_copy_to_dumb_buffer (GstKMSSink * self, GstVideoInfo * vinfo,
   gboolean success;
   GstBuffer *buf = NULL;
 
+  if (GST_VIDEO_INFO_IS_AFBC (vinfo)) {
+    GST_ERROR_OBJECT (self, "unable to copy AFBC");
+    return NULL;
+  }
+
   if (!ensure_internal_pool (self, vinfo, inbuf))
     goto bail;
 
@@ -1846,6 +1950,9 @@ gst_kms_sink_drain (GstKMSSink * self)
 
     dumb_buf = gst_kms_sink_copy_to_dumb_buffer (self, &self->last_vinfo,
         parent_meta->buffer);
+    if (!dumb_buf)
+      dumb_buf = gst_buffer_ref (self->last_buffer);
+
     last_buf = self->last_buffer;
     self->last_buffer = dumb_buf;
 
diff --git a/sys/kms/gstkmsutils.h b/sys/kms/gstkmsutils.h
index 657007068..1654e28bc 100644
--- a/sys/kms/gstkmsutils.h
+++ b/sys/kms/gstkmsutils.h
@@ -30,6 +30,36 @@
 
 G_BEGIN_DECLS
 
+#ifndef DRM_FORMAT_MOD_VENDOR_ARM
+#define DRM_FORMAT_MOD_VENDOR_ARM 0x08
+#endif
+
+#ifndef DRM_FORMAT_MOD_ARM_AFBC
+#define DRM_FORMAT_MOD_ARM_AFBC(__afbc_mode) fourcc_mod_code(ARM, __afbc_mode)
+#endif
+
+#ifndef AFBC_FORMAT_MOD_BLOCK_SIZE_16x16
+#define AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 (1ULL)
+#endif
+
+#ifndef AFBC_FORMAT_MOD_SPARSE
+#define AFBC_FORMAT_MOD_SPARSE (((__u64)1) << 6)
+#endif
+
+#define DRM_AFBC_MODIFIER \
+  (DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE) | \
+   DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16))
+
+#ifndef GST_VIDEO_FLAG_ARM_AFBC
+#define GST_VIDEO_FLAG_ARM_AFBC (1UL << 31)
+#define GST_VIDEO_INFO_SET_AFBC(i) \
+  GST_VIDEO_INFO_FLAG_SET (i, GST_VIDEO_FLAG_ARM_AFBC)
+#define GST_VIDEO_INFO_UNSET_AFBC(i) \
+  GST_VIDEO_INFO_FLAG_UNSET (i, GST_VIDEO_FLAG_ARM_AFBC)
+#define GST_VIDEO_INFO_IS_AFBC(i) \
+  GST_VIDEO_INFO_FLAG_IS_SET (i, GST_VIDEO_FLAG_ARM_AFBC)
+#endif
+
 GstVideoFormat gst_video_format_from_drm (guint32 drmfmt);
 guint32        gst_drm_format_from_video (GstVideoFormat fmt);
 guint32        gst_drm_bpp_from_drm (guint32 drmfmt);
-- 
2.20.1

