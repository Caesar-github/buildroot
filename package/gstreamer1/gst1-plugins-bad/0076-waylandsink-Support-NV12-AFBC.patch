From 00de90802cd3444752e76d884d3f196a900c1a66 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Fri, 12 Nov 2021 11:14:37 +0800
Subject: [PATCH 76/76] waylandsink: Support NV12(AFBC)

Tested on RK356x with:
gst-play-1.0 video.mp4 --videosink=waylandsink

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 ext/wayland/gstwaylandsink.c | 45 ++++++++++++++++++++++++++++++++++++
 ext/wayland/wldisplay.c      | 14 ++++++++++-
 ext/wayland/wldisplay.h      | 37 +++++++++++++++++++++++++++++
 ext/wayland/wllinuxdmabuf.c  | 21 ++++++++++++++++-
 ext/wayland/wlwindow.c       | 19 +++++++++------
 ext/wayland/wlwindow.h       |  2 +-
 6 files changed, 128 insertions(+), 10 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 99b41577a..4dff6afea 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -645,6 +645,9 @@ gst_wayland_sink_get_caps (GstBaseSink * bsink, GstCaps * filter)
     gst_structure_take_value (gst_caps_get_structure (caps, 1), "format",
         &dmabuf_list);
 
+    if (sink->display->support_afbc)
+      gst_caps_set_simple (caps, "arm-afbc", GST_TYPE_INT_RANGE, 0, 1, NULL);
+
     GST_DEBUG_OBJECT (sink, "display caps: %" GST_PTR_FORMAT, caps);
   }
 
@@ -692,6 +695,8 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
   GstWaylandSink *sink;
   gboolean use_dmabuf;
   GstVideoFormat format;
+  GstStructure *s;
+  gint value;
 
   sink = GST_WAYLAND_SINK (bsink);
 
@@ -701,6 +706,29 @@ gst_wayland_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
   if (!gst_video_info_from_caps (&sink->video_info, caps))
     goto invalid_format;
 
+  /* parse AFBC from caps */
+  s = gst_caps_get_structure (caps, 0);
+  if (gst_structure_get_int (s, "arm-afbc", &value)) {
+    if (value)
+      GST_VIDEO_INFO_SET_AFBC (&sink->video_info);
+    else
+      GST_VIDEO_INFO_UNSET_AFBC (&sink->video_info);
+  }
+
+  /* HACK: Hide MPP offsets in the last plane's offset/stride */
+  if (GST_VIDEO_INFO_N_PLANES (&sink->video_info) == GST_VIDEO_MAX_PLANES)
+    goto invalid_format;
+
+  if (!gst_structure_get_int (s, "offset-x", &value))
+    value = 0;
+
+  GST_VIDEO_INFO_OFFSET_X (&sink->video_info) = value;
+
+  if (!gst_structure_get_int (s, "offset-y", &value))
+    value = 0;
+
+  GST_VIDEO_INFO_OFFSET_Y (&sink->video_info) = value;
+
   format = GST_VIDEO_INFO_FORMAT (&sink->video_info);
   sink->video_info_changed = TRUE;
 
@@ -746,9 +774,17 @@ gst_wayland_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
   GstBufferPool *pool = NULL;
   gboolean need_pool;
   GstAllocator *alloc;
+  GstStructure *s;
+  gint value;
 
   gst_query_parse_allocation (query, &caps, &need_pool);
 
+  s = gst_caps_get_structure (caps, 0);
+  if (gst_structure_get_int (s, "arm-afbc", &value) && value) {
+    GST_DEBUG_OBJECT (sink, "no allocation for AFBC");
+    return FALSE;
+  }
+
   if (need_pool)
     pool = gst_wayland_create_pool (sink, caps);
 
@@ -915,6 +951,9 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
           &sink->video_info);
   }
 
+  if (!wbuf && GST_VIDEO_INFO_IS_AFBC (&sink->video_info))
+    goto no_afbc;
+
   if (!wbuf && gst_wl_display_check_format_for_shm (sink->display, format)) {
     if (gst_buffer_n_memory (buffer) == 1 && gst_is_fd_memory (mem))
       wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
@@ -1047,6 +1086,12 @@ no_wl_buffer:
     ret = GST_FLOW_ERROR;
     goto done;
   }
+no_afbc:
+  {
+    GST_ERROR_OBJECT (sink, "could not import AFBC");
+    ret = GST_FLOW_ERROR;
+    goto done;
+  }
 activate_failed:
   {
     GST_ERROR_OBJECT (sink, "failed to activate bufferpool.");
diff --git a/ext/wayland/wldisplay.c b/ext/wayland/wldisplay.c
index 355109716..ec4ab7d2e 100644
--- a/ext/wayland/wldisplay.c
+++ b/ext/wayland/wldisplay.c
@@ -147,8 +147,20 @@ dmabuf_format (void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf,
     g_array_append_val (self->dmabuf_formats, format);
 }
 
+static void
+dmabuf_modifier (void *data, struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf,
+    uint32_t format, uint32_t modifier_hi, uint32_t modifier_lo)
+{
+  GstWlDisplay *self = data;
+  uint64_t modifier = ((uint64_t)modifier_hi << 32) | modifier_lo;
+
+  if (modifier == DRM_AFBC_MODIFIER)
+    self->support_afbc = TRUE;
+}
+
 static const struct zwp_linux_dmabuf_v1_listener dmabuf_listener = {
   dmabuf_format,
+  dmabuf_modifier,
 };
 
 gboolean
@@ -239,7 +251,7 @@ registry_handle_global (void *data, struct wl_registry *registry,
         wl_registry_bind (registry, id, &wp_viewporter_interface, 1);
   } else if (g_strcmp0 (interface, "zwp_linux_dmabuf_v1") == 0) {
     self->dmabuf =
-        wl_registry_bind (registry, id, &zwp_linux_dmabuf_v1_interface, 2);
+        wl_registry_bind (registry, id, &zwp_linux_dmabuf_v1_interface, 3);
     zwp_linux_dmabuf_v1_add_listener (self->dmabuf, &dmabuf_listener, self);
   }
 }
diff --git a/ext/wayland/wldisplay.h b/ext/wayland/wldisplay.h
index d9389773b..5ff75389b 100644
--- a/ext/wayland/wldisplay.h
+++ b/ext/wayland/wldisplay.h
@@ -31,6 +31,42 @@
 
 G_BEGIN_DECLS
 
+#ifndef DRM_FORMAT_MOD_VENDOR_ARM
+#define DRM_FORMAT_MOD_VENDOR_ARM 0x08
+#endif
+
+#ifndef DRM_FORMAT_MOD_ARM_AFBC
+#define DRM_FORMAT_MOD_ARM_AFBC(__afbc_mode) fourcc_mod_code(ARM, __afbc_mode)
+#endif
+
+#ifndef AFBC_FORMAT_MOD_BLOCK_SIZE_16x16
+#define AFBC_FORMAT_MOD_BLOCK_SIZE_16x16 (1ULL)
+#endif
+
+#ifndef AFBC_FORMAT_MOD_SPARSE
+#define AFBC_FORMAT_MOD_SPARSE (((__u64)1) << 6)
+#endif
+
+#define DRM_AFBC_MODIFIER \
+  (DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_SPARSE) | \
+   DRM_FORMAT_MOD_ARM_AFBC(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16))
+
+#ifndef GST_VIDEO_FLAG_ARM_AFBC
+#define GST_VIDEO_FLAG_ARM_AFBC (1UL << 31)
+#define GST_VIDEO_INFO_SET_AFBC(i) \
+  GST_VIDEO_INFO_FLAG_SET (i, GST_VIDEO_FLAG_ARM_AFBC)
+#define GST_VIDEO_INFO_UNSET_AFBC(i) \
+  GST_VIDEO_INFO_FLAG_UNSET (i, GST_VIDEO_FLAG_ARM_AFBC)
+#define GST_VIDEO_INFO_IS_AFBC(i) \
+  GST_VIDEO_INFO_FLAG_IS_SET (i, GST_VIDEO_FLAG_ARM_AFBC)
+#endif
+
+/* HACK: Hide MPP offsets in the last plane's offset/stride */
+#define GST_VIDEO_INFO_OFFSET_X(i) \
+  GST_VIDEO_INFO_PLANE_OFFSET (i, GST_VIDEO_MAX_PLANES - 1)
+#define GST_VIDEO_INFO_OFFSET_Y(i) \
+  GST_VIDEO_INFO_PLANE_STRIDE (i, GST_VIDEO_MAX_PLANES - 1)
+
 #define GST_TYPE_WL_DISPLAY                  (gst_wl_display_get_type ())
 #define GST_WL_DISPLAY(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_DISPLAY, GstWlDisplay))
 #define GST_IS_WL_DISPLAY(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_DISPLAY))
@@ -62,6 +98,7 @@ struct _GstWlDisplay
   struct zwp_linux_dmabuf_v1 *dmabuf;
   GArray *shm_formats;
   GArray *dmabuf_formats;
+  gboolean support_afbc;
 
   /* private */
   gboolean own_display;
diff --git a/ext/wayland/wllinuxdmabuf.c b/ext/wayland/wllinuxdmabuf.c
index 2bfbca5db..bac058d87 100644
--- a/ext/wayland/wllinuxdmabuf.c
+++ b/ext/wayland/wllinuxdmabuf.c
@@ -46,6 +46,7 @@ gst_wl_linux_dmabuf_construct_wl_buffer (GstBuffer * buf,
   guint nplanes, flags = 0;
   struct zwp_linux_buffer_params_v1 *params;
   ConstructBufferData data;
+  guint64 modifier = GST_VIDEO_INFO_IS_AFBC (info) ? DRM_AFBC_MODIFIER : 0;
 
   g_return_val_if_fail (gst_wl_display_check_format_for_dmabuf (display,
           GST_VIDEO_INFO_FORMAT (info)), NULL);
@@ -61,6 +62,24 @@ gst_wl_linux_dmabuf_construct_wl_buffer (GstBuffer * buf,
       G_GSSIZE_FORMAT " (%d x %d), format %s", info->size, width, height,
       gst_wl_dmabuf_format_to_string (format));
 
+  if (modifier) {
+    if (format == DRM_FORMAT_NV12) {
+      /* Mali uses DRM_FORMAT_YUV420_8BIT for NV12(AFBC) */
+#ifndef DRM_FORMAT_YUV420_8BIT
+#define DRM_FORMAT_YUV420_8BIT fourcc_code('Y', 'U', '0', '8')
+#endif
+      format = DRM_FORMAT_YUV420_8BIT;
+      nplanes = 1;
+
+      /* Mali might ignore this stride, so let's use it as width */
+      width = GST_VIDEO_INFO_PLANE_STRIDE (info, 0);
+    } else {
+      GST_ERROR_OBJECT (mem->allocator, "only support AFBC for NV12");
+      data.wbuf = NULL;
+      goto out;
+    }
+  }
+
   /* Creation and configuration of planes  */
   params = zwp_linux_dmabuf_v1_create_params (display->dmabuf);
 
@@ -74,7 +93,7 @@ gst_wl_linux_dmabuf_construct_wl_buffer (GstBuffer * buf,
       GstMemory *m = gst_buffer_peek_memory (buf, mem_idx);
       gint fd = gst_dmabuf_memory_get_fd (m);
       zwp_linux_buffer_params_v1_add (params, fd, i, m->offset + skip,
-          stride, 0, 0);
+          stride, modifier >> 32, modifier & 0xFFFFFFFF);
     } else {
       GST_ERROR_OBJECT (mem->allocator, "memory does not seem to contain "
           "enough data for the specified format");
diff --git a/ext/wayland/wlwindow.c b/ext/wayland/wlwindow.c
index ba7af693f..98bf080e7 100644
--- a/ext/wayland/wlwindow.c
+++ b/ext/wayland/wlwindow.c
@@ -458,6 +458,9 @@ gst_wl_window_resize_video_surface (GstWlWindow * window, gboolean commit)
   dst.w = window->render_rectangle.w;
   dst.h = window->render_rectangle.h;
 
+  src.x = window->video_offset_x;
+  src.y = window->video_offset_y;
+
   if (window->video_viewport) {
     if (window->fill_mode == GST_WL_WINDOW_STRETCH) {
       res = dst;
@@ -471,19 +474,14 @@ gst_wl_window_resize_video_surface (GstWlWindow * window, gboolean commit)
 
       if (src_ratio < dst_ratio) {
         int h = src.w / dst_ratio;
-        src.y = (src.h - h) / 2;
+        src.y += (src.h - h) / 2;
         src.h = h;
       } else if (src_ratio > dst_ratio) {
         int w = src.h * dst_ratio;
-        src.x = (src.w - w) / 2;
+        src.x += (src.w - w) / 2;
         src.w = w;
       }
 
-      // Crop src
-      wp_viewport_set_source (window->video_viewport,
-          wl_fixed_from_int (src.x), wl_fixed_from_int (src.y),
-          wl_fixed_from_int (src.w), wl_fixed_from_int (src.h));
-
       // Fill dst
       res = dst;
     }
@@ -494,6 +492,10 @@ gst_wl_window_resize_video_surface (GstWlWindow * window, gboolean commit)
     gst_video_sink_center_rect (src, dst, &res, FALSE);
   }
 
+  wp_viewport_set_source (window->video_viewport,
+      wl_fixed_from_int (src.x), wl_fixed_from_int (src.y),
+      wl_fixed_from_int (src.w), wl_fixed_from_int (src.h));
+
   wl_subsurface_set_position (window->video_subsurface, res.x, res.y);
 
   if (commit) {
@@ -546,6 +548,9 @@ gst_wl_window_render (GstWlWindow * window, GstWlBuffer * buffer,
         gst_util_uint64_scale_int_round (info->width, info->par_n, info->par_d);
     window->video_height = info->height;
 
+    window->video_offset_x = GST_VIDEO_INFO_OFFSET_X (info);
+    window->video_offset_y = GST_VIDEO_INFO_OFFSET_Y (info);
+
     wl_subsurface_set_sync (window->video_subsurface);
     gst_wl_window_resize_video_surface (window, FALSE);
     gst_wl_window_set_opaque (window, info);
diff --git a/ext/wayland/wlwindow.h b/ext/wayland/wlwindow.h
index 01a1f2336..215520de8 100644
--- a/ext/wayland/wlwindow.h
+++ b/ext/wayland/wlwindow.h
@@ -74,7 +74,7 @@ struct _GstWlWindow
   GstVideoRectangle video_rectangle;
 
   /* the size of the video in the buffers */
-  gint video_width, video_height;
+  gint video_width, video_height, video_offset_x, video_offset_y;
 
   /* this will be set when viewporter is available and black background has
    * already been set on the area_subsurface */
-- 
2.20.1

